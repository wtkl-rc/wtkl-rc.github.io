---
layout: post
title:  "c++基础学习"
date:   2023-05-14 08:54:15 +0800
categories: jekyll c++基础学习
---

# 抽象类

抽象类是一种特殊的类，他不能被实例化，只能被用作派生类的基类，抽象类内必须包含至少一个纯虚函数。

# 动态联编

就是运行时多态

# 双目运算符



# 模板函数

# 多态

分为编译时多态和运行时多态

虚函数是用于实现运行时多态

# 虚基类



# 多态性和虚函数



隐藏规则，赋值兼容原则，多态性

函数还不能放在析构函数后面



**1、在动态分配堆上内存的时候，析构函数必须是虚函数**

**原因：**动态分配堆上内存，无法自动回收。若基类指针指向派生类，然后基类指针调用`delete`方法，只能释放基类的内存，无法释放派生类特有的部分内存，进而导致内存泄露。

析构函数定义成虚函数，基类指针调用`delete`方法，会先调用派生类的析构函数，然后自动调用基类的析构函数。

析构函数必须是定义虚函数，但没有必要是纯虚的。



```
char ch[10]={'/0'};         ch[0]=='/0'
```









有四个运算符不可以重载

堆内存是程序员自己管理的，栈内存是系统管理的

基类的析构函数，设为虚类，这样的话只会产生一个堆对象，应该是吧



# 类的组合和聚集

将数据成员中包含对象成员的类称为组合类    同生共死

数据成员中包含对象指针的类称为聚合类      不是同生共死





const  传入使用



栈

析构函数 

先创建的对象后出来



构建

祖先（基类）先客人再自己



析构

先自己再客人 祖先



差不多就是初始化的意思

```
ListNode() : val(0), next(nullptr) {}
等效于下面的代码
ListNode( ) {    val = 0;    next = nullptr; }
```



# 继承与派生

派生类的成员函数可以直接访问基类的共有和保护成员

定义一个派生类时，若不使用保留字显式的规定采用何种继承方式，默认私有继承

构造函数的调用顺序为，基类、对象成员所属类、自己所属类   ？？

# 构造函数

没有定义的话就是默认构造函数，默认构造函数不进行任何初始化

```
//定义
<类名>::构造函数名(<形式参数表>){}
//带有初始列表
<类名>::<构造函数>(<参数表>):<变量1>(<初值1>),…, <变量n>(<初值n>){}
```

## 拷贝构造函数

 拷贝构造函数的功能是用一个已有的对象来初始化一个被创建的同类对象

## 派生类构造函数

```
在定义派生类对象时，其相应的基类对象需调用带有参数的构造函数。 
派生类构造函数(参数表):基类构造函数(参数表),对象成员1 (参数表)……，对象成员n (参数表)
{ 派生类新增成员的初始化语句；}

C3DPoint::C3DPoint(double x,double y,double z):Point(x,y),m_dz(z){}
```

有点类似传参的作用，C3DPoint(double x,double y,double z) 这里面有所有的参数，是派生类构造函数。

Point(x,y),m_dz(z) 是参数的来源，point提供x，y    m_dz是派生类的数据成员



 如果派生类的基类也是一个派生类，每个派生类只需负责其直接基类的构造，依次上溯。

定义派生类构造函数时，先基类，再对象成员，再派生类本身

# 析构函数

派生类与基类的析构函数没有什么关系

顺序：
先派生类本身，再对象成员，后基类



# 多继承

```
class<派生类名>:[继承方式]基类名1,[继承方式]基类名2,...,[继承方式]基类名n 
{
// 定义派生类自己的成员；
}；

```

多重继承：由多个基类派生而来

## 赋值兼容原则

# 多态性

四种表现形式：

函数重载

运算符重载

模板stl

虚函数：运行时多态

## 虚基类

大概就是a是基类。   b，c继承类a。    d又继承b，c    其基类只被一次继承

```
class B:virtual public A
```

当一个类多次间接从基类派生以后，其基类只被一次继承

## 纯虚函数

纯虚函数或抽象类，没有函数体只是在基类进行声明，派生类必须实现函数才能创建对象。

```
virtual void abstractFunction() = 0;  //=0表示这个函数是纯虚函数
```

## 虚函数

虚函数就是能在派生类中被重写，从而实现多态性。

```
 virtual int fun();
```



## 运算符重载

函数类型 operator 运算符（形参）{

}

在类里面定义：

```
Point operator +(const Point& p2)
{
Point p3;
p3.x=this->x+p2.x;
p3.y=this->y+p2.y;

return p3;
}

p3=p1. operator +(p2)
p3=p1+p2;

```

类外定义：

```
Point operator +(const Point& p1,const Point& p2)
{
Point p3;
p3.x=p1.x+p2.x;
p3.y=p1.y+p2.y;

return p3;
}
```

# 友元

借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。

友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数

友元函数可以访问当前类中的所有成员函数

## 友元类

不仅可以将一个函数声明为一个类的朋友，还可以将整个类声明为另一个类的朋友。友元类中的所有成员函数都是另外一个类的友元函数

友元的关系是单向的而不是双向的，b是类a的友元类，不等于a是类b的友元类，类a中的成员函数不能访问类b中的private成员

友元关系不能传递

# 面向对象综合

## 类的组合和聚集

c++语言将数据成员包含的对象成员的类称为组合类----同生共死

数据成员中包含对象指针的类称为聚合类-----不是同生共死



## 深拷贝与浅拷贝

当没有显示的给出拷贝构造函数时，编译器就弥补一个拷贝构造函数，其功能仅能完成浅拷贝

浅拷贝：

浅拷贝大概就是两个指针指向同一块地址，当我们释放内存的时候，要重复释放。解决方法就是使用深拷贝，这样在堆内存开辟一块新空间，两个指针指向不同的堆内存。

深拷贝：

只要类属性里面有指针等就必须使用深拷贝

大概就只当我要用拷贝构造函数时，类里面有指针，那么我就要自己在拷贝构造函数里面new出一块空间，让指针指向这块空间



同时在析构函数上面也要做一些判断

## 静态成员

由static修饰类体中的成员，称为静态成员。

类的静态成员为其所有对象共享，不管有多少对象，静态成员只有一份存于公共内存中，静态数据成员被当做该类类型的全局对象



用关键字static修饰的数据成员为静态数据成员。由该类型实例化的 所有对象，共享系统为静态成员分配的一个存储空间，而这个存储空间是程序执行main函数之前分配的，在实例化对象时不再为静态成员分配空间（静态成员数据不在对象空间中）。

看的不是很懂，大概就是静态成员数据不在对象空间中



总结：

同全局变量相比，静态成员有两个优势

1 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其他全局名字冲突的可能性

2 可以实现信息隐藏，静态成员可以是private成员，而全局变量则不能



使用格式

类名::静态数据成员名 或 对象.静态数据成员名



通过定义一个全局变量统计当前学生总数，全局变量可以实现对象的共享，但是没有权限的限制，导致其他的函数或者对象可以无限制修改，则会出现问题(不安全）；

使用static，利用普通成员变量进行统计，普通成员变量是本类某个对象独有的，类作用域，不能实现共享，外界修改不了（比较安全）。



4、若类中含有静态成员，则该成员不在能本类中开辟空间，静态数据成员不占类的大小，不能在构造函数中初始化。



总结：

1、设计静态数据成员目的是信息共享和信息交流

2、类的静态数据成员为所有类对象所共享，不属于某个具体的实例

3、类的静态数据成员必须在类外定义，定义时不添加static关键字，不能在构造函数的初始化列表中创建

4、在类的成员函数中使用静态数据成员，静态数据成员之前没有this

5、当类的静态数据成员为公有时，可以在外部函数使用：类名::静态数据成员名 或 对象.静态数据成员名，可以在类体中定义自身的静态类型对象

## 静态方法

在对象之外可以采用下面的方式

类名::函数名 或 对象名.函数名

静态成员函数没有this指针，因此在静态成员函数显示的使用this会错误



总结：

一个常规的成员函数声明描述了三件在逻辑上相互不同的事情：

 

该函数能访问类声明的私用部分。

该函数位于类的作用域之中。

该函数必须由一个对象去激活（有一个this指针）。

将一个函数声明为友元可以使它只具有第一种性质。

将一个函数声明为static可以使它只具有第一种和第二种性质。

## 常成员与常对象

c++中可以将对象成员声明为const，包括常数据成员和常成员函数

### 常数据成员

常数据成员的作用与一般常变量相似

常数据成员的值是不能改变的，只能通过构造函数的参数初始化列表对常数据成员进行初始化，不能采用在构造函数中对常数据成员赋初值的方法

常对象的数据成员都是常数据成员，因此常对象的构造函数只能用参数初始化表对常数据成员进行初始化。

### c++常成员函数

一般成员函数可以引用本类中的非const数据成员，也可以修改他们，如果将成员函数声明为常成员函数，则只能引用本类中的数据成员，不能修改他们

常成员函数可以引用const数据成员，也可以引用非const的数据成员

const数据成员可以被const成员函数引用，也可以被非const的成员函数引用

注意事项：

如果在一个类中，有些数据成员的值允许改变，另一些数据成员的值不允许改变，则可以将一部分数据成员声明为const，以保证其值不被改变。

如果要求所有的数据成员的值都不允许改变，则可以将所有的数据成员声明为const。

如果已定义了一个常对象，只能调用其中的const成员函数，而不能调用非const成员函数。

## const常引用

我们可以用这几条函数传入参数

```
int p
int &p
int const &p    上面两条都可以在函数内改变他的值，这条不可以改变   
```



## 对象与函数

### 类对象作为函数形参

### 对象作为函数的返回值

### 类对象作为输出参数









24.多态性的含义及内容

多态性是指当不同对象收到相同的消息时产生不同的动作。

包括运行时多态：虚函数

编译时多态：重载（函数重载、运算符重载）模板（函数模板类模板）

23.简述结构化的程序设计、面向对象的程序设计的基本思想

结构化的程序设计**将数据和对数据的操作分离**程序是由一个个函数组成的

面向对象的程序设计将**数据和操作封装在一起**，程序是由一个个对象组成的，对象之间通过接口进行通信，它能够较好的支持程序代码的复用

22、在什么时候函数的参数类型使用常引用

如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中改变，就应该使用常引用

21、简述debug和release版本的区别

debug版本是调试版本，release版本是发布给用户的最终非调试版本

20、什么是常指针，什么是指向常变量的指针

常指针的含义是该     **指针指向的地址不变**，但该地址所指向的内容可以变化。

指向常变量的指针是指该     指针的变量本身的地址可以变化，可以指向其他的变量，但是它所指的内容不可修改            ？？

19、c++中分配内存的三种方式

静态存储区：是在程序编译时就已经分配好的，在整个运行期间都存在，如全局变量、常量

栈上分配：函数内的局部变量就是从这分配的，但分配的内存容易有限

堆上分配：也成为动态分配，如我们用new分配内存，用delete来释放内存

？？？

18值传递，指针传递，引用传递

17、什么函数不能声明wield虚函数

构造函数

16、引用与指针有什么区别

引用必须被初始化 指针不必

引用初始化以后不能被改变  指针可以改变所指的对象

不存在指向空值的引用   但是存在指向存在空值的指针

15、c++中类型为private的成员变量可以由哪些函数访问

只可以由本类中的成员函数和友元函数访问

12、解释堆和栈的区别

栈区由系统自动分配释放，存放函数的参数值，局部变量的值等

堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由os回收

11、构造函数和析构函数是否可以被重载，为什么

析构函数可以被重载，析构函数不可以被重载。因为构造函数可以带多个参数。而析构函数只有一个，不能被重载

10、是不是一个父类写了一个virtual函数，如果子类覆盖它的函数不加virtual也能实现多态

virtual修饰符会被隐形继承

virtual可加可不加，子类覆盖他的函数不加也能够实现多态

9.请说出private和protect public三种访问限制类型的区别

pri是私有类型   只有本类中的成员函数可以访问

pro是保护型     本类和继承类可以访问

public   任何类都可以访问

8、赋值运算符和拷贝构造函数的区别与联系

相同点：都是将一个对象copy到另一个对象中去  ？？

不同点：拷贝构造函数涉及到要新建一个对象

7、什么叫抽象类它有什么特点

包含虚函数的类是抽象函数，抽象类不能实例化对象

6、构造函数与普通函数相比在形式上有什么不同（构造函数的作用，他的声明形式类分析）

构造函数是类的一种特殊成员函数，一般情况下它是专门来初始化对象的成员变量的

构造函数的名字必须与类名相同，它不具任何类型，不返回任何值

5、c++编译器自动为类产生的四个缺省函数是什么

默认构造函数、拷贝构造函数、析构函数、赋值运算符重载函数

4、成员函数通过什么来区分不同对象的成员数据，为什么他能够区分

通过this指针来区分 因为它指向的是对象的首地址

3、在类的内部定义成用户那函数的函数体，这种函数具备什么特点

这种函数会被自动为内联函数这猴子那个函数在函数调用的地方在编译阶段都会进行代码替换





保护成员

如果在类中声明了保护成员那么他的派生类可以访问保护成员

派生类中的成员函数能够访问基类中的保护和公有

派生类的对象能够访问公有

类的继承方式为私有继承，基类中的公有成员被继承后变成派生类中的私有成员，派生类的成员函数可以访问它们，但是在类的外部通过派生类的对象无法对其进行访问。
