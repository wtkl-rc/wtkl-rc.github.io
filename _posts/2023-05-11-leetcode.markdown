---
layout: post
title:  "力扣"
date:   2023-05-11 08:54:15 +0800
categories: jekyll leetcode 
---

# 数组

#  27.移除元素

```c++
暴力破解法
程序不能运行
int removeElement(vector<int>& nums, int val) {
    int i;
    int k=sizeof(nums)-1;        //数组长度
    for(i=0;i<=k;i++){            //遍历数组
        if(nums[i]==val){
            for(int j=i;j<k;j++){            //移动数组
                    nums[j]=nums[j+1];
            }
            k--;
            i--;
        }
    }
    return k;
  }
```

```
双指针法
快慢指针法
用的就是两个指针，一个快指针和一个慢指针，开始时两个指针同时移动，移动到目标元素后，慢指针不动，快指针移动。慢指针的元素变为快指针的元素，实现元素替换。
int removeElement(vector<int>& nums, int val) {
	    int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (val != nums[fastIndex]) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
}
```



# 977.有序数组的平方

第一个想法：直接先平方后排序

```
#include <vector>
#include <iostream>
using namespace std;

class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int k;
        int i=0;
        int length =nums.size();
        for(i=0;i<length;i++){   //遍历数组
            nums[i]=nums[i]*nums[i];
        }

        for(k=length;k!=1;k--){
            for(i=0;i<k-1;i++){
                if(nums[i]>nums[i+1]){
                int j=nums[i];
                nums[i]=nums[i+1];
                nums[i+1]=j;
                }
            } 
        }

        return nums;
    }
};
```

这个算法理论上来说是可以的，但是算法时间复杂度太高，所以力扣不通过，后续优化一下。

问题：

1.排序不会，研究排序花了点时间

2.对于sizeof和.size的区别

总花费大约1小时

别人的代码优化：

```
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int k;
        int i=0;
        int length =nums.size();
        for(i=0;i<length;i++){   //遍历数组
            nums[i]*=nums[i];
        }
     sort(nums.begin(), nums.end()); // 快速排序
        return nums;
    }
};
```

用sort函数

# 209.长度最小的子数组

在数组中找到  数组连续元素之和  为大于或等于target的最小子数组

暴力破解法：

不能用，力扣超时

```
class Solution {
public:
     int minSubArrayLen(int target, vector<int>& a) {
        int length=0;
        int i;
        int add=0;
        int size=sizeof(a)/sizeof(int);
        
        for(i=0;i<size;i++){
            while(add<target){
                add=a[i]+a[i+1];
                length++;
            } 
        }
        return length;
    }
};
```

滑动窗口法：



问题：怎么判断子序列长度是最小的

# 59.螺旋矩阵

分单双数

n=7为单数：

确定从外圈从左到右，上到下

一共有n=7则4圈    n=5则3圈   n=3则2圈

四个for循环，一个for循环循环n-1次，左闭右开

start确定开始位置，第一圈开始位置为0，第二圈开始为1第三圈开始为2

```
res[][]值的确定
第一圈上行res[0][0]，res[0][1]，res[0][2]，res[0][3]
第二圈上行res[1][1],res[1][2],res[1][3],res[1][4]
```

双数：

n=6则3圈  n=4则2圈  

一个for循环n-1 左闭右开

```
int loop=n/2//先确定单双数，确定循环几圈
while(loop--){  //loop不为0的时候循环
	for(){       
	}
}

```

重最外围开始考虑，如n的值可以为什么，单双数

建立模型，开始模拟，接着分析数据，确定关系

# 链表

# 203.移除链表元素

注意此题的头结点，头节点也有值。要先从头结点开始判断，再判断后面结点的值，同时还要对最后一个结点处理。

```
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        
            while(head!=NULL&&head->val==val){        //判断头结点是否为val 	
                if(head->next==NULL){				//如果只有头结点一个结点，直接将头节点指向null
                    head=NULL;
                }else{							//否则指向头结点的下一个结点
                    head=head->next;
                }      
            }
        
       
        if(head!=NULL&&head->next!=NULL){
            ListNode* p=head;			//定义两个指针，同时从头结点开始
            ListNode* before=head;			
            
            while(p!=NULL&&p->next!=NULL){  //判断指针是否为null			
                if(p->val==val){          //如果相等的话，就要进行交换
                    before->next=p->next;		//将前面的指针的next域指向后继结点
                    p=p->next;
                }

                if(p->val!=val){		//如果后继结点还是等于val，那么b还是指向原来的结点
                    before=p;
                    p=p->next;
                }

            }

            if(p!=NULL&&p->val==val){          //最后一个结点，如果相等的话，就要进行交换
                    before->next=NULL;
                }
        }
     return head;
    }
};

```



