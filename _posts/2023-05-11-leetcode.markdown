---
layout: post
title:  "力扣"
date:   2023-05-11 08:54:15 +0800
categories: jekyll leetcode
---

#  27.移除元素

```c++
暴力破解法
程序不能运行
int removeElement(vector<int>& nums, int val) {
    int i;
    int k=sizeof(nums)-1;        //数组长度
    for(i=0;i<=k;i++){            //遍历数组
        if(nums[i]==val){
            for(int j=i;j<k;j++){            //移动数组
                    nums[j]=nums[j+1];
            }
            k--;
            i--;
        }
    }
    return k;
  }
```

```
双指针法
快慢指针法
用的就是两个指针，一个快指针和一个慢指针，开始时两个指针同时移动，移动到目标元素后，慢指针不动，快指针移动。慢指针的元素变为快指针的元素，实现元素替换。
int removeElement(vector<int>& nums, int val) {
	    int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (val != nums[fastIndex]) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
}
```



# 977.有序数组的平方

第一个想法：直接先平方后排序

```
#include <vector>
#include <iostream>
using namespace std;

class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int k;
        int i=0;
        int length =nums.size();
        for(i=0;i<length;i++){   //遍历数组
            nums[i]=nums[i]*nums[i];
        }

        for(k=length;k!=1;k--){
            for(i=0;i<k-1;i++){
                if(nums[i]>nums[i+1]){
                int j=nums[i];
                nums[i]=nums[i+1];
                nums[i+1]=j;
                }
            } 
        }

        return nums;
    }
};
```

这个算法理论上来说是可以的，但是算法时间复杂度太高，所以力扣不通过，后续优化一下。

问题：

1.排序不会，研究排序花了点时间

2.对于sizeof和.size的区别

总花费大约1小时

别人的代码优化：

```
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int k;
        int i=0;
        int length =nums.size();
        for(i=0;i<length;i++){   //遍历数组
            nums[i]*=nums[i];
        }
     sort(nums.begin(), nums.end()); // 快速排序
        return nums;
    }
};
```

用sort函数

# 209.长度最小的子数组

在数组中找到  数组连续元素之和  为大于或等于target的最小子数组

暴力破解法：

```
class Solution {
public:
     int minSubArrayLen(int target, vector<int>& a) {
        int length=0;
        int i;
        int add=0;
        int size=sizeof(a)/sizeof(int);
        
        for(i=0;i<size;i++){
            while(add<target){
                add=a[i]+a[i+1];
                length++;
            } 
        }
        return length;
    }
};
```

滑动窗口法：

```
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            
            while (sum >= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
            
        }
        
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```
